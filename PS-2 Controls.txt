module TopLevel(
    input CLOCK_50,
    input reset,
    inout PS2_CLK,
    inout PS2_DAT,
    output [6:0] HEX0
);

    wire [7:0] received_data;
    wire received_data_en;

    // Instantiate the PS/2 Controller
    PS2_Controller ps2_controller (
        .CLOCK_50(CLOCK_50),
        .reset(reset),
        .PS2_CLK(PS2_CLK),
        .PS2_DAT(PS2_DAT),
        .received_data(received_data),
        .received_data_en(received_data_en)
    );

    // Instantiate the Arrow Key Detector
    ArrowKeyDetector arrow_key_detector (
        .CLOCK_50(CLOCK_50),
        .reset(reset),
        .received_data(received_data),
        .received_data_en(received_data_en),
        .HEX0(HEX0)
    );

endmodule




PS2_Controller.v:

module PS2_Controller (
    input CLOCK_50,
    input reset,
    inout PS2_CLK,
    inout PS2_DAT,
    output reg [7:0] received_data,
    output reg received_data_en
);

    // State machine states
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam PARITY_CHECK = 2'b10;
    localparam FINALIZE = 2'b11;

    reg [1:0] state, next_state;
    
    reg [7:0] data_reg;
    reg [3:0] bit_count;
    reg ps2_clk_d, ps2_data_d;
    reg ps2_clk_sync, ps2_data_sync;

    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            ps2_clk_sync <= 1'b1;
            ps2_data_sync <= 1'b1;
        end else begin
            ps2_clk_sync <= PS2_CLK;
            ps2_data_sync <= PS2_DAT;
        end
    end

    // Sample the PS2 data on the falling edge of PS2_CLK
    always @(negedge ps2_clk_sync or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 4'b0;
			received_data <= 8'b0;
            received_data_en <= 0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    received_data_en <= 0;
                    if (~ps2_clk_sync) begin // Detect start of transmission (falling edge of PS2_CLK)
                        next_state <= RECEIVE;
                        bit_count <= 0;
                    end else begin
                        next_state <= IDLE;
                    end
                end
                
                RECEIVE: begin
                    if (~ps2_clk_sync) begin // Capture data on falling edge of PS2_CLK
                        data_reg <= {ps2_data_sync, data_reg[7:1]}; // Shift in data bit
                        bit_count <= bit_count + 1;
                        if (bit_count == 8) begin // When 8 data bits are received
                            next_state <= PARITY_CHECK;
                        end else begin
                            next_state <= RECEIVE;
                        end
                    end else begin
                        next_state <= RECEIVE;
                    end
                end
                
                PARITY_CHECK: begin
                    next_state <= FINALIZE;
                end
                
                FINALIZE: begin
                    received_data <= data_reg;
                    received_data_en <= 1;
                    next_state <= IDLE;
                end
                
                default: next_state <= IDLE;
            endcase
        end
    end

endmodule

ArrowKeyDetector.v :

module ArrowKeyDetector (
    input CLOCK_50,
    input reset,
    input [7:0] received_data,
    input received_data_en,
    output reg [6:0] HEX0
);

    reg [7:0] prev_data;

    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            HEX0 <= 7'b1111111; // Blank display
            prev_data <= 8'h00;
        end else if (received_data_en) begin
            if (prev_data == 8'hE0) begin
                case (received_data)
                    8'h75: HEX0 <= 7'b1000000; // "0" for Up Arrow
                    8'h72: HEX0 <= 7'b1111001; // "1" for Down Arrow
                    8'h6B: HEX0 <= 7'b0100100; // "2" for Left Arrow
                    8'h74: HEX0 <= 7'b0110000; // "3" for Right Arrow
                    default: HEX0 <= 7'b1111111; // Blank display if not an arrow key
                endcase
            end
            prev_data <= received_data;
        end
    end

endmodule
